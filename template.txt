// DO NOT EDIT THIS FILE !
// It is generated by persist tool, source from {{.Source}}.
package {{.Package}}

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/gotips/log"
	"strconv"
	"strings"
	{{- range .Imports}}
	{{.}}{{- end }}
)

type {{ .Name }} struct{}

{{- range .Methods }}

func (*{{ $.Name }}) {{ .Name }}({{range $i,$vt := .Params}}{{if $i | ne 0}}, {{end}}{{$vt.Var}} {{$vt.Slice}}{{$vt.Star}}{{$vt.Package}}{{and $vt.Package "."}}{{$vt.Type}}{{ end }}) ({{range $i,$vt := .Returns}}{{if $i | ne 0}}, {{end}}{{$vt.Var}} {{$vt.Slice}}{{$vt.Star}}{{$vt.Package}}{{and $vt.Package "."}}{{$vt.Type}}{{ end }}) {
	var err error
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}
	var stmt string
{{- range .Fragments}}
{{if .Cond }}
	if {{.Cond}} {
{{- end}}
	stmt = "{{.Stmt}} "
{{- range $i, $vt := .Args}}
	{{- if eq .SQLIn true}}
		for _, v := range {{.Scope}}{{and .Scope "."}}{{$vt.Var}} {
			args = append(args, {{ $vt.Alias}}{{and $vt.Alias "("}}v{{and $vt.Alias ")"}})
		}
		stmt = strings.Replace(stmt, "$%d",
			strings.Repeat(",$%d", len({{.Scope}}{{and .Scope "."}}{{.Var}}))[1:], -1)

	{{- else if .Marshal }}
		{{.Scope}}{{and .Scope "_"}}{{.Var}}, err := json.Marshal({{.Scope}}{{and .Scope "."}}{{.Var}})
		if err != nil {
			log.Errorf("marshal(%#v) error: %s",{{.Scope}}{{and .Scope "."}}{{.Var}}, err)
		}
		args = append(args, {{.Scope}}{{and .Scope "_"}}{{.Var}})

	{{- else }}
		args = append(args, {{ $vt.Alias}}{{and $vt.Alias "("}}{{$vt.Scope}}{{and .Scope "."}}{{$vt.Var}}{{and $vt.Alias ")"}})
	{{- end }}
{{- end }}
	query.WriteString(stmt)
	{{- if .Cond}}
	}{{end}}
{{- end}}

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt = fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)

{{- if .Type | eq "add" }}
	{{- if .Unmarshals}}
	var {{range $i, $vt := .Unmarshals}}{{if ne $i 0}}, {{end}}{{or $vt.Scope "_x"}}{{$vt.Concat}}{{$vt.Var}}{{end}} []byte
	{{- end}}
	{{ if .Scans }}
	dest := []interface{}{ {{range $i, $vt := .Scans}}{{if ne $i 0}}, {{end}}&{{or $vt.Scope "_x"}}{{$vt.Concat}}{{$vt.Var}}{{end}} }
	err = {{.Tx}}.QueryRow(stmt, args...).Scan(dest...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return err
	}
	return nil
	{{else}}
	res, err := {{.Tx}}.Exec(stmt, args...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return 0, err
	}
	return res.RowsAffected()
	{{end}}

{{- else if .Type | eq "modify"}}
	res, err := {{.Tx}}.Exec(stmt, args...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return 0, err
	}
	return res.RowsAffected()

{{- else if .Type | eq "remove"}}
	res, err := {{.Tx}}.Exec(stmt, args...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return 0, err
	}
	return res.RowsAffected()

{{- else if .Type | eq "get"}}
	var _x {{.Result.Package}}{{and .Result.Package "."}}{{.Result.Type}}
	{{ if .Unmarshals }}
	var {{range $i, $vt := .Unmarshals}}{{if ne $i 0}}, {{end}}{{or $vt.Scope "_x"}}{{$vt.Concat}}{{$vt.Var}}{{end}} []byte
	{{ end }}
	dest := []interface{}{ {{range $i, $vt := .Scans}}{{if ne $i 0}}, {{end}}&{{or $vt.Scope "_x"}}{{$vt.Concat}}{{$vt.Var}}{{end}} }

	err ={{.Tx}}.QueryRow(stmt, args...).Scan(dest...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return nil, err
	}

	{{- range .Unmarshals}}
	{{or .Scope "_x"}}{{and .Concat "."}}{{.Var}} = {{.Slice}}{{if .Slice}}{{.Star}}{{else}}{{and .Star "&"}}{{end}}{{.Package}}{{and .Package "."}}{{.Type}}{}
		err = json.Unmarshal({{or .Scope "_x"}}{{.Concat}}{{.Var}}, &{{or .Scope "_x"}}{{and .Concat "."}}{{.Var}})
		if err != nil {
			log.Error(err)
			log.Error(stmt)
			log.Error(args...)
		}
	{{- end}}
	return &_x, nil

{{- else if .Type | eq "count"}}
	var _x {{range $i, $r := .Returns}}{{if eq $i 0}}{{.Type}}{{end}}{{end}}
	err = {{.Tx}}.QueryRow(stmt, args...).Scan(&_x)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return 0, err
	}
	return _x, nil

{{- else if .Type | eq "list"}}
	rows, err := {{.Tx}}.Query(stmt, args...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return nil, err
	}
	defer rows.Close()

    var xs {{.Result.Slice}}{{.Result.Star}}{{.Result.Package}}{{and .Result.Package "."}}{{.Result.Type}}
	for rows.Next() {
		var _x {{.Result.Package}}{{and .Result.Package "."}}{{.Result.Type}}
		xs = append(xs, &_x)

		{{ if .Unmarshals}}
		var {{range $i, $vt := .Unmarshals}}{{if ne $i 0}}, {{end}}{{or $vt.Scope "_x"}}{{$vt.Concat}}{{$vt.Var}}{{end}} []byte
		{{ end }}
        dest := []interface{}{ {{range $i, $vt := .Scans}}{{if ne $i 0}}, {{end}}&{{or $vt.Scope "_x"}}{{$vt.Concat}}{{$vt.Var}}{{end}} }

		err = rows.Scan(dest...)
		if err != nil {
			log.Error(err)
			log.Error(stmt)
			log.Error(args...)
			return nil, err
		}

		{{- range .Unmarshals}}
		{{or .Scope "_x"}}{{and .Concat "."}}{{.Var}} = {{.Slice}}{{if .Slice}}{{.Star}}{{else}}{{and .Star "&"}}{{end}}{{.Package}}{{and .Package "."}}{{.Type}}{}
		err = json.Unmarshal({{or .Scope "_x"}}{{.Concat}}{{.Var}}, &{{or .Scope "_x"}}{{and .Concat "."}}{{.Var}})
		if err != nil {
			log.Errorf("unmarshal(%s) error: %s",{{or .Scope "_x"}}{{.Concat}}{{.Var}}, err)
		}
		{{- end}}
	}
	if err = rows.Err(); err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return nil, err
	}
	return xs, nil

{{- end}}
}
{{- end}}
