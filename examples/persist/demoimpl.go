// DO NOT EDIT THIS FILE !
// It is generated by persist tool, source from demo.go.
package persist

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/gotips/log"
	"strconv"
	"database/sql"
	"github.com/arstd/persist/examples/domain"
)

var _ = json.Marshal
var _ = fmt.Sprintf
var _ = strconv.Itoa

type DemoPersist struct{}

func (*DemoPersist) Add(d *domain.Demo) ( error) {
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}

		query.WriteString("insert into demos(name, third_field, status, content) values($%d, $%d, $%d, $%d) returning id ")
		args = append(args, d.Name)
		args = append(args, d.ThirdField)
		d_Status, err := json.Marshal(d.Status)
		if err != nil {
			log.Errorf("marshal(%#v) error: %s",d.Status, err)
		}
		args = append(args, d_Status)
		d_Content, err := json.Marshal(d.Content)
		if err != nil {
			log.Errorf("marshal(%#v) error: %s",d.Content, err)
		}
		args = append(args, d_Content)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt := fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	
	dest := []interface{}{ &d.Id }
	err = db.QueryRow(stmt, args...).Scan(dest...)
	if err != nil {
		log.Errorf("insert(%s, %#v) error: %s", stmt, args, err)
		return err
	}
	

	return nil
}

func (*DemoPersist) Modify(d *domain.Demo) ( error) {
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}

		query.WriteString("update demos set name=$%d, third_field=$%d, status=$%d, content=$%d where id=$%d ")
		args = append(args, d.Name)
		args = append(args, d.ThirdField)
		d_Status, err := json.Marshal(d.Status)
		if err != nil {
			log.Errorf("marshal(%#v) error: %s",d.Status, err)
		}
		args = append(args, d_Status)
		d_Content, err := json.Marshal(d.Content)
		if err != nil {
			log.Errorf("marshal(%#v) error: %s",d.Content, err)
		}
		args = append(args, d_Content)
		args = append(args, d.Id)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt := fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	res, err := db.Exec(stmt, args...)
	if err != nil {
		log.Errorf("update(%s, %#v) error: %s", stmt, args, err)
		return err
	}
	a, err := res.RowsAffected()
	if err != nil {
		log.Errorf("update(%s, %#v) error: %s", stmt, args, err)
		return err
	} else if a != 1 {
		log.Errorf("update(%s, %#v) expected affected 1 row, but actual affected %d rows",
			stmt, args, a)
		return fmt.Errorf("expected affected 1 row, but actual affected %d rows", a)
	}
	return nil
}

func (*DemoPersist) Remove(id int) ( error) {
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}

		query.WriteString("delete from demos where id=$%d ")
		args = append(args, id)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt := fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	res, err := db.Exec(stmt, args...)
	if err != nil {
		log.Errorf("delete(%s, %#v) error: %s", stmt, args, err)
		return err
	}
	a, err := res.RowsAffected()
	if err != nil {
		log.Errorf("delete(%s, %#v) error: %s", stmt, args, err)
		return err
	} else if a != 1 {
		log.Errorf("delete(%s, %#v) expected affected 1 row, but actual affected %d rows",
			stmt, args, a)
		return fmt.Errorf("expected affected 1 row, but actual affected %d rows", a)
	}
	return nil
}

func (*DemoPersist) Get(id int) ( *domain.Demo,  error) {
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}

		query.WriteString("select id, name, third_field, status, content from demos where id=$%d ")
		args = append(args, id)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt := fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	var x domain.Demo
	var x_Content []byte
	dest := []interface{}{ &x.Id, &x.Name, &x.ThirdField, &x.Status, &x_Content }

	err := db.QueryRow(stmt, args...).Scan(dest...)
	if err != nil {
		log.Errorf("query(%s, %#v) error: %s", stmt, args, err)
		return nil, err
	}
	x.Content = &domain.Demo{}
		err = json.Unmarshal(x_Content, &x.Content)
		if err != nil {
			log.Errorf("unmarshal(%s) error: %s",x_Content, err)
		}
	return &x, nil
}

func (*DemoPersist) Count(tx *sql.Tx, d *domain.Demo, statuses []domain.Status) ( int64,  error) {
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}

		query.WriteString("select count(id) from demos where name=$%d ")
		args = append(args, d.Name)

	if d.ThirdField != false {
		query.WriteString("and third_field=$%d ")
		args = append(args, d.ThirdField)
	}

	if d.Content != nil {
		query.WriteString("and content=$%d ")
		d_Content, err := json.Marshal(d.Content)
		if err != nil {
			log.Errorf("marshal(%#v) error: %s",d.Content, err)
		}
		args = append(args, d_Content)
	}

	if len(statuses) != 0 {
		query.WriteString("and status=any($%d::integer[]) ")
		arr := "{"
		for i, v := range statuses {
			if i > 0 {
				arr += ","
			}
			arr += strconv.Itoa(int(v))
		}
		arr += "}"

		args = append(args, arr)
	}

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt := fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	var count int64
	err := db.QueryRow(stmt, args...).Scan(&count)
	if err != nil {
		log.Errorf("query(%s, %#v) error: %s", stmt, args, err)
		return 0, err
	}
	return count, nil
}

func (*DemoPersist) List(tx *sql.Tx, d *domain.Demo, statuses []domain.Status, page int, size int) ( []*domain.Demo,  error) {
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}

		query.WriteString("select id, name, third_field, status, content from demos where name=$%d ")
		args = append(args, d.Name)

	if d.ThirdField != false {
		query.WriteString("and third_field=$%d ")
		args = append(args, d.ThirdField)
	}

	if d.Content != nil {
		query.WriteString("and content=$%d ")
		d_Content, err := json.Marshal(d.Content)
		if err != nil {
			log.Errorf("marshal(%#v) error: %s",d.Content, err)
		}
		args = append(args, d_Content)
	}

	if len(statuses) != 0 {
		query.WriteString("and status=any($%d::integer[]) ")
		arr := "{"
		for i, v := range statuses {
			if i > 0 {
				arr += ","
			}
			arr += strconv.Itoa(int(v))
		}
		arr += "}"

		args = append(args, arr)
	}

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt := fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	rows, err := db.Query(stmt, args...)
	if err != nil {
		log.Errorf("query(%s, %#v) error: %s", stmt, args, err)
		return nil, err
	}
	defer rows.Close()

    var xs []*domain.Demo
	for rows.Next() {
		var x domain.Demo
		xs = append(xs, &x)

		var x_Content []byte
        dest := []interface{}{ &x.Id, &x.Name, &x.ThirdField, &x.Status, &x_Content }

		err = rows.Scan(dest...)
		if err != nil {
			log.Errorf("scan rows for query(%s, %#v) error: %s", stmt, args, err)
			return nil, err
		}
		x.Content = &domain.Demo{}
		err = json.Unmarshal(x_Content, &x.Content)
		if err != nil {
			log.Errorf("unmarshal(%s) error: %s",x_Content, err)
		}
	}
	if err = rows.Err(); err != nil {
		log.Errorf("scan rows for query(%s, %#v) last error: %s", stmt, args, err)
		return nil, err
	}
	return xs, nil
}
